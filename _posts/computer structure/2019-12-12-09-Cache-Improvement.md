---
layout : post
date : 2019-12-12
title : Cache Improvement
catetories : [Computer Structure]
---

## 캐시 성능의 향상 

캐시 성능을 향상하는 방법이 두 가지 있다.  

1. 연관 사상 (associative mapping)  
2. 다단계 사상 (multilevel caching)  

1은 캐시 실패율을 줄이는데 목적이 있고  
2는 실패하더라도 밑에서 또 캐시를 참조하여 메모리 접근을 줄이는 것이다.  

CPU 시간은 (CPU 내 프로그램 수행 클럭 사이클 수 + 메모리 지연 클럭 사이클) * 클럭 사이클 시간이다.  
때문에 메모리까지 가서 지연되는 시간을 줄여야 한다.  
이는 캐시로 해결될 수 있다.  


### 캐시 성능 계산

예)  
명령어 캐시 실패율 = 2%  
데이터 캐시 실패율 = 4%  
메모리 지연 없을 시 CPI = 2  
실패 손실 = 100 사이클  
적재, 저장 명령어 실행 빈도 = 36% 라 가정했을 때  

명령어 개수를 I 라 가정할 때  
명령어 실패 사이클 = I * 2% * 100 = 2.00 * I  
데이터 실패 사이클 = I * 36% * 4% * 100 = 1.44 * I  
전체 메모리 지연 사이클 수 = 2.00 * I + 1.44 * I = 3.44 * I  
메모리 지연을 고려할 경우의 CPI = 2 + 3.44 = 5.44  
캐시가 완벽할 시 성능 개선 = 5.44/2 = 2.72  

결과 : CPI 가 2일 시 성능은 2.72배이다.  
1이라면 (1 + 3.44)/1 이므로 4.44배를 기대할 수 있다.  



### 블록 배치를 유연하게

세 가지 블록 배치 방법

1. 직접 사상 (direct mapping)  
2. 집합 연관 사상 (set-associative mapping)  
3. 완전 연관 사상 (fully associative mapping)  

직접 사상 캐시는 메모리 블록이 딱 하나에만 들어간다.  
한 값만 저장되는 것이다.  

완전 연관 사상 캐시는  
직접 사상 캐시와 정반대로,  
메모리 블록이 캐시 블록 아무데나 들어갈 수 있지만  
주어진 블록을 찾기 위해서는 캐시 내 모든 태그를 비교해야 한다.  


### n-way 집합 연관 캐시

직접 사상과 완전 연관 사상의 중간  

각 블록이 배치될 수 있는 위치가 n개  
집합은 인덱스가 같은 n개의 캐시 블록  
집합의 크기 = n  
집합의 개수 = 캐시의 블록 수 / n  

메모리 블록은 캐시 내의 한 집합으로 사상한다.  
인덱스 필드에서 집합의 번호를 찾을 수가 있다. 그에 해당하는 집합 안에서 찾자.  
물론 그 안에서는 모든 태그를 검색해야 한다.  

연관 정도 -> n 을 증가시키면  
실패율이 감소하고, 대신 적중 시간이 증가한다.  
그러니 적당히 늘리자.  


캐시 크기가 m 블록이라 할 때  
1-way 집합 연관 캐시는 곧 직접 사상 캐시이고  
m-way 집합 연관 캐시는 완전 연관 캐시이다.  


### 각 캐시의 예

직접 사상, 2-way 집합 연관 사상, 완전 연관 사상 캐시가 있다.  

이때 찾으려는 값이 0, 8, 0, 6, 8 순일 때  
직접 사상은 값 하나만 저장하므로 모두 실패일 것이고  
2-way 에선 두 번째 0에서 한 번 성공할 것이고 (마지막 8을 찾을 때는 0과 6만 있을 것)  
완전 연관에선 각 숫자가 처음으로 등장하는 것 빼고 다 성공할 것이다.  

따라서 연관 정도가 증가하면 실패율이 감소한다.  
하지만 이도 적당히 늘려야 하는 것이,  
연관 정도를 늘리면 실패율이 줄어드는 것은 항상 맞지만,  
어느정도 늘리면 향상이 별로 없다.  




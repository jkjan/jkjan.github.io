---
date : 2019-12-13
title : Graph
categories : [Algorithm]
---

## 그래프

그래프는 객체와 객체의 관계를 수학적으로 표현한 모델이다.   
Vertex 와 Edge 의 집합으로 표현된다.  
1:1 관계 밖에 표현하지 못하고  
트리나 스택 구조와 다르게 해석의 여지가 여러가지 일 수도 있다는 단점이 있다.  

### 그래프의 유형  

그래프는 가중치와 방향을 가지며  
그 유무에 따라서 네 종류로 나뉜다.  

1. Graph : 방향도 가중치도 없다.  
2. Weighted Graph : 방향은 없으나 가중치가 있다.  
3. Directed Graph : 가중치는 없으나 방향이 있다.  
4. Weighted Directed Graph : 방향과 가중치가 둘 다 있다.  

### 그래프의 표현 방식

그래프는 한 버텍스와 그에 인접한 버텍스들의 리스트인  
인접 리스트들의 집합으로 표현될 수도 있고  
연결 됐는지 안 됐는지, 혹은 가중치가 얼마인지를 표현하는  
행렬로 표현할 수도 있다.  

이때 그래프를 이용한 알고리즘에서  
인접 리스트를 활용하는 것이 더 시간이 덜 든다.  


그래프의 모양으로는  
희소 그래프 (Sparse Graph) 와  
완전 그래프 (Complete Graph) 가 있다.  

완전 그래프는 모든 버텍스가 연결이 된 것으로  
이때는 인접 리스트로 구현하든 행렬로 구현하든 차이가 없다. 어차피 다 연결이 됐으니까.  

단 희소 그래프일 때 인접 리스트로 구현하면 연결이 안 된 곳은 계산 자체를 안 하므로  
시간, 공간도 O(n) 이 나오지만 (n은 버텍스의 개수)  
행렬로 구현한다면 뭘 하든 O(n^2) 가 나온다.  


### 그래프의 탐색

그래프의 탐색에는  
깊이 우선 탐색과 (Depth First Search, 이하 DFS)  
넓이 우선 탐색이 있다. (Breadth First Search, 이하 BFS)  

방향도 가중치도 없는 일반 그래프이고  
버텍스 넘버는 0부터 시작한다고 가정하자.  

먼저 그래프를 입력 받는다.  

입력은 버텍스 수, 엣지 수  
그리고 그 다음 줄부터 엣지의 수만큼  
시작 노드와 도착 노드가 '유일하게' 주어진다고 가정한다.  

```C++
void input() {
  int V, E; // 버텍스와 엣지의 개수
  int from, to; // 출발, 도착 버텍스 
  graph = new vector<int>[V];
  visited = new bool[V];
  fill_n(visited, V, false);
  cin >> V >> E;
  for (int i = 0; i < E; i++) {
    cin >> from >> to;
    graph[from].push_back(to);
    graph[to].push_back(from);
  }
}
```

입출력을 위해 iostream 을,  
그래프 저장을 위해 vector 를,  
bfs 에서 쓰일 큐를 위해 queue 를 인클루드 하였다.  

그래프는 벡터들의 배열로 구현하였다.  
탐색 시 중복 방문을 방지하기 위하여 visited 라는 bool 배열을 선언한다.  
버텍스 수가 입력되면 그만큼 그래프와 visited 의 공간을 할당해준다.  
(백준 같이 최대 입력 수가 주어지면 위에서 미리 그만큼 할당해도 된다.)  

이후 엣지의 수만큼 입력을 받아 그래프에 저장한다.  

이 그래프를 dfs 한 후, bfs 할 것이다.  


dfs 의 코드이다.  

```C++
void dfs(int v) {
  visited[v] = true;
  for (vector<int>::iterator itor = graph[v].begin(); itor != graph[v].end(); ++itor) {
    if (!visited[*itor]) {
        cout << v << " goes to " << *itor << endl;
        dfs(*itor);
    }
  }
}
```

bfs 의 코드이다.  

```C++
void bfs() {
  queue<int> willVisit;
  int nowVisit;
  visited[0] = true;
  willVisit.push(0);
  while(!willVisit.empty()) {
    nowVisit = willVisit.front();
    willVisit.pop();
    for (vector<int>::iterator itor = graph[nowVisit].begin(); itor != graph[nowVisit].end(); ++itor) {
      if(!visited[*itor]) {
          cout << nowVisit << " goes to " << *itor << endl;
          willVisit.push(*itor);
      }
    }
  }
}
```

위 세 함수를 사용한 메인 함수이다.  

```C++
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

vector<int>* graph;
bool* visited;

void input();
void dfs(int v);
void bfs();

int main() {
  input();
  dfs(0);
  fill_n(visited, V, false);
  bfs();
  
  delete[] graph;
  delete[] visited;
  return 0;
}
```

우리는 이 dfs 와 bfs 로 많은 것을 할 수 있다.  
dfs 로는 강한 연결 요소와 이중 연결 요소를,  
bfs 로는 버텍스간의 최단 거리를 찾을 수 있다.  

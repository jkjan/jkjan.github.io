---
date : 2019-12-11
title : Processor
---

## 기본적인 MIPS 구현
- 핵심적인 MIPS 명령어 집합의 부분집합을 구현한다.  

1. 메모리 참조 명령어 (lw, sw 등)  
2. 산술 - 논리 명령어 (add, sub, AND, OR, slt 등의 R 타입)  
3. 분기 명령어        (beq, j 등)  

이는 단순히 구현하거나,  
컴퓨터 구조의 8원칙 중 하나인 파이프라이닝으로 구현할 수 있다.  


## 명령어의 단계 

1, 2단계는 공통이다.

1. 명령어를 받는다. (fetch) 이후 PC 를 증가시킨다.  
2. 명령어를 해독한다. (opcode 분류, 레지스터 읽기)  

3. 실행한다.  
    - 메모리 참조 명령어의 경우 : 주소 계산을 위해,  
    - 산술 - 논리 명령어의 경우 : 연산 수행을 위해,  
    - 분기 명령어의 경우        : 비교하기 위해 ALU 를 사용한다.  

4. 결과를 저장한다.  
    - 메모리 참조 명령어의 경우  
          sw 라면 데이터 기록하기 위해 메모리 접근,  
          lw 라면 데이터 읽기 위하여 메모리 접근 후 레지스터에 저장  
          
    - 산술 - 논리 명령어의 경우 : ALU 연산 결과를 레지스터에 저장  
    - 분기 명령어의 경우        : 비교 결과에 따라 PC 에 값을 저장  
                                  (참이면 PC에 새 주소를, 거짓이면 4 증가)  
                                  
따라서 명령어들마다 연결되어야 하는 회로가 다르므로,  
설계의 효율성을 위해 멀티플렉서를 사용한다.  
이는 서로 다른 곳에서 나온 데이터가 같은 유닛으로 갈 때 효율적이다.  

단계적으로 데이터패스를 구현해보자.   


## 데이터패스 만들기

### 명령어 인출

첫째로 명령어를 저장하는 명령어 메모리가 필요하다.  
이는 읽기 전용이고, 출력은 입력 주소가 지정하는 번지의 명령어만 해당한다.  

실행 중인 명령어의 주소가 저장되는  
Program Counter, 일명 PC가 필요하다.  
이는 사이클 한 번 당 항상 증가하므로 쓰기 제어신호는 필요 없다.  

PC를 32비트 상수, 즉 4바이트 씩 더해줄 덧셈기가 필요하다.  
PC 에서 명령어가 출력되는 순간 그 PC 값은 덧셈기로 가서 4와 더해진 후 다시 PC에 들어간다.  

[!pc](./pc.jpg)



### R 형식 명령어

R 형식 명령어는 3단계에서 연산 수행을 위해 ALU 를 사용하고,  
4단계에서 그 결과를 레지스터에 저장했다.  

R 형식의 명령어는  

op | rs | rt | rd | shamt | funct |  

rs 와 rt 를 funct 한 후,  
혹은 rt 를 shamt 만큼 shift 한 후 rd 에 저장하는 명령어이다.  

따라서 이는 rs rt rd 의 5비트 짜리 명령어를 다 쓰게 되는데,  
명령어에 따라 rd 를 쓸 지 안 쓸지,  
뒤의 16비트를 저장할 주소로 판별할지 말지를 정해주기 위해,  
그리고 명령어에서 쓰인 레지스터들을 선택하기 위해 MUX가 사용된다.  

[!rtype](./rtype.jpg)

위 그림에서, r 타입 명령어는 data 에 접근해서 값을 수정하지 않기 때문에,  
이를 방지해주기 위해 RegWrite 라는 셀렉터가 필요함을 알 수 있다.  

또한 레지스터를 선택할 때도,  
입력된 레지스터 번호에 따라서 회로를 유동적으로 뗐다 붙였다 할 수 없으므로  
MUX 를 써서 해당되는 레지스터에만 신호를 줌으로서 선택을 한다.  



### 메모리 참조 명령어의 실행

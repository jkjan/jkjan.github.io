---
title : Process
categories : [Operating System]
date : 2020-04-06

---

&nbsp;

## 프로세스

&nbsp;&nbsp;

프로세스는 실행 중인 프로그램을 의미하며,  컴퓨팅의 기본이 된다.

이는 운영 체제의 관리 대상이다.

&nbsp;

운영 체제 내부에서는 다양한 수준에서의 프로세스 스케쥴링이 일어난다.

&nbsp;

프로세스의 동작에는 생성, 종료, 대기 등이 있다.

&nbsp;

프로세스 간 통신 (Interprocess Communication, IPC) 에는 

message passing과 shared-memory 방식이 있다.

이에는 POSIX, Mach 등의 예가 있다.

&nbsp;

또한 프로세스 간 통신, 소켓, IPC, 통신 서버 같은

클라이언트-서버 시스템의 통신에 대해서 알아본다.

&nbsp;


## 멀티프로그래밍

&nbsp;

멀티프로그래밍은 운영 체제의 기본 동작 원리이다.


&nbsp;

<img src="https://user-images.githubusercontent.com/22045424/78552362-55bf5a80-7842-11ea-8f6b-fb6ecb0faee4.png" width="70%">  

&nbsp;
  
Uni-Programming 은 일을 한 번에 하나씩 처리한다.

프로세스가 입출력을 하든 뭘 하든 

CPU가 할 게 없는 idle (=게으른) 상태에도 다른 일로 전환하지 않고

그걸 곧이 곧대로 기다리고 있다.

그리고 한 작업이 끝나면 그제서야 CPU 사용이 전환된다.

위  그림에서 회색 줄은 입출력으로 인해 CPU가 노는 상태이다.

CPU 같은 고가 장비를 idle 상태로 두면 대단한 낭비가 아닐 수 없다.

&nbsp;

반면 Multi-Programming 은 CPU를 놀리지 않고

다른 프로그램이 바로 사용할 수 있도록 CPU 사용을 전환한다.

위에서 A 프로세스가 입출력 상태에 돌입하자마자 

이를 기다리지 않고 바로 B 프로세스를 처리하고 있는 것을 확인할 수 있다.

CPU와 입출력 장치는 독립적 장치이기 때문에

문제될 것이 하나도 없다.

Uni-Programming 방식과 달리, CPU가 노는 구간이 없이 계속해서 일을 처리한다.



Multi-Programming 은 시스템 전체의 처리량, 생산성이 늘어난다.

이는 운영 체제의 성능을 나타내는 지표로 사용된다.

또한 자원마다 얼마나 활용이 가능한지를 나타내는 활용도가 늘어난다.

Multi-Programming 에서는 전체 구간에서 CPu가 항상 사용되므로 거의 100%라고 볼 수 있다.

Multi-Programming의 정도(degree)는 동시에 실행할 수 있는 프로그램의 개수이다. 

이것은 높을 수록 좋다.

 &nbsp;

## 프로세스 개념

&nbsp;

운영 체제는 다양한 프로그램을 실행한다.

이는 배치 시스템에서는 **jobs** 라고 하며

time-shared 시스템에서는 **사용자 프로그램(user program)** 혹은 **작업(task)** 이라고 한다.

**프로세스**란 실행 중의 프로그램이다.

&nbsp;

<img src="https://user-images.githubusercontent.com/22045424/78553383-1bef5380-7844-11ea-802c-075dceae3809.png" width="30%">  

&nbsp;

프로세스에는 여러 부분으로 나뉠 수 있다.

* **텍스트 영역(text section)** 이라고 불리는 프로그램 코드 부분
* **프로그램 카운터(program counter)** 와 프로세서 레지스터를 포함하는 현재의 활동
* 매개변수, 복귀 주소, 로컬 변수 같은 임시 데이터가 있는 **스택(stack)**
* 전역 변수가 있는 **데이터 영역(data)**
* 실행되면서 동적으로 할당되는 메모리가 있는 **힙(heap)**

&nbsp;

위 사진은 메모리 상에 올라간 프로세스의 구조를 나타낸다.

상대적인 위치인 0부터

프로세스마다 할당된 메모리 크기 max 안에

stack, 빈 공간, heap, data, text 영역이 구분되어 있다.

&nbsp;

stack, heap 을 제외하고 data와 text 영역은 크기가 고정되어 있다.

그림의 화살표는 stack 은 위에서 점점 내려오면서 크기가 증가하고,

heap 은 위로 점점 올라가며 빈 공간을 사용할 수 있음을 의미한다.

이때 stack 이 빈 공간을 다 써버려서, 

heap이나 그 밑의 영역까지 침범해버리면 stack overflow가 발생한다.

&nbsp;

&nbsp;

프로그램은 디스크(**실행 가능한 파일**)에 저장된 **수동적인** 존재이며

프로세스는 다음에 실행할 CPU 명령을 지정하는 Program Counter와

실행에 필요한 자원의 집합을 가지는 **능동적인** 존재이다.

즉, 프로그램 그 자체는 프로세스가 아니다.

실행 가능한 파일이 메모리에 적재되어야 비로소 프로그램이 프로세스가 된다.

&nbsp;

프로그램은 GUI의 마우스 클릭, 

혹은 이름을 command line 으로 입력하는 것이나 기타 방법으로 실행할 수 있다.

&nbsp;

하나의 프로그램이 여러 프로세스를 가질 수 있다.

여러 사용자가 하나의 프로그램을 실행한다고 생각해보자.  

이때는 text는 동일해도 stack, data, heap은 다를 것이다.

&nbsp;

&nbsp;

## 프로세스 상태

&nbsp;

프로세스가 실행되면 **상태**가 바뀐다.

프로세스는 아래 5개의 상태 중 하나의 상태를 가진다.

* new : 프로세스가 생성된 상태이다.

  

* ready : 프로세스가 프로세서에게 지정되기를 기다리고 있는 상태이다.

  - 프로세스에게 CPU가 주어지면 실행할 수가 있다.

    이는 프로세스가 실행을 위해 CPU를 기다리고 있는 상태라고 해석해도 된다.

    

* running : 명령어가 실행되고 있다. 실행은 CPU 하나에 오직 하나만 실행된다.

  

* waiting : 프로세스가 어떤 이벤트가 발생하기를 기다리고 있다.

  - 이는 입출력의 완료 등이 있다.

    이때는 CPU가 주어져도 즉시 실행할 수가 없는 상태이다.

    

* terminated : 프로세스가 실행을 마친 상태이며, 아직 소멸되지는 않은 상태이다.

&nbsp;

&nbsp;

## 프로세스 상태 다이어그램

&nbsp;

<img src="https://user-images.githubusercontent.com/22045424/78554285-d9c71180-7845-11ea-8c96-d454cd434a63.png" width="70%">  

&nbsp;

프로세스는 생성부터 종료까지,

new 부터 terminated 까지의 상태 변화를 겪는다.

&nbsp;

1. 프로세스는 생성되면 new 상태에 돌입한다. 

   이때 운영 체제는 new 상태의 프로세스 중에서 

   정식으로 프로세스가 될 대상을 선택한다.

   프로세스가 선택되는 것을 admitted라고 한다. 

   &nbsp;

2. 프로세스가 admitted 되면, ready 상태에 돌입한다. 

   운영 체제는 이 상태의 프로세스 중 하나를 골라 CPU를 준다.(assign)

   이를 scheduler dispatch라고 한다.

   &nbsp;

3. 프로세스에 CPU가 할당되면 프로세스는 running 상태가 된다.

   이때 이 프로세스가 갈 수 있는 곳은 세 가지이다.

   1. 프로세스가 너무 장시간 존재하면 CPU를 빼앗기게 된다.

      timer interrupt는 프로세스는 CPU를 얼마나 쓰고 있는지 조사하여

      운영 체제가 프로세스에게서 CPU를 빼앗는 것이 가능하게 한다.

      이렇게 되면 다시 ready 상태로 돌아가 CPU를 기다리게 된다.

   2. 실행 중인 프로세스가 종료하는 시스템 콜을 호출하면 

      운영 체제가 해당 프로세스의 상태를 running에서 terminated 로 바꾼다.

      이를 exit이라고 한다.

   3. 입출력 장치를 요청하게 되면, 그 작업이 완료될 때까지 기다려야 한다.

      이때 프로세스는 waiting 상태에 돌입한다.

      &nbsp;

4. waiting 상태에서 프로세스는 프로세스가 이전에 요청한 입출력의 완료나

   특정 사건의 발생을 기다리게 된다. 이때 이것이 충족이 되면, 

   운영 체제는 인터럽트를 발생시켜서 완료되었다고 프로세스에게 알려준다.

   이때 프로세스는 다시 ready로 가서 CPU의 할당을 기다리게 된다.

   &nbsp;

   &nbsp;

## 프로세스 제어 블록 (PCB)

&nbsp;

커널이 개별 프로세스를 관리하기 위해 유지하는 자료 구조이다.

이 안에는 한 프로세스에 대한 모든 정보가 들어있다. **task control block**이라고도 불린다.

PCB는 프로세스마다 하나씩 존재한다.

프로세스가 생성되면 PCB가 생성되고, 종료 시 삭제된다.

&nbsp;

<img src="https://user-images.githubusercontent.com/22045424/78555206-7f2eb500-7847-11ea-88c2-7eb657a833db.png" width="30%">  

&nbsp;

* 프로세스 상태 : running, waiting 등의 상태를 나타낸다.

  

* 프로세스 ID : 프로세스마다 고유 식별 번호를 가지고 있으며 이것으로 프로세스를 구별한다.

  PID라고도 한다.

  

* 프로그램 카운터 : CPU 안의 PC 레지스터의 복사본이다. 

  이 값은 running 이 아닌 경우에만 의미가 있다.

  프로세스가 가장 최근에 실행이 멈춘 곳으로, 나중에 재개할 때 사용된다.

  

* CPU 레지스터들 : 프로세스에 사용되는 레지스터들의 내용들이다.

  PC를 제외한 레지스터를 저장한다. 실행 멈춘 시점의 값들이 복사된다.

  

* CPU 스케쥴링 정보 : 우선 순위, 스케쥴링 큐 포인터가 담겨있다.

  CPU를 할당할 프로세스를선택하는데 쓰인다.

  

* 메모리 관리 정보 : 프로세스에 할당된 메모리에 관한 정보이다.

  프로세스가 할당받아 사용 중인 메인 메모리의 위치 정보를 나타낸다.

  

* 이용 정보 : 사용된 CPU, 시작부터 계산된 clock time, 시간 제한에 대한 정보이다.

  자원 사용 기록으로, 이용한만큼 과금되는 시스템이라면 이 정보를 활용한다.

  

* 입출력 상태 정보 : 프로세스에게 할당된 입출력 장치와 열려있는 파일들의 리스트이다.



&nbsp;

커널은 현재 동작하는 모든 PCB들을 모아서 연결 리스트로 관리한다.


---
title : Computer System Architecture 
categories : [Operating System]  
date : 2020-03-19
---

# 컴퓨터 시스템의 구조  

![image](https://user-images.githubusercontent.com/22045424/77042801-aa1fa900-69ff-11ea-9798-4a9e9f88df12.png)

컴퓨터 시스템은 다음과 같은 네 요소로 나뉠 수가 있다.  

1. 사용자  
사용자는 하나 이상의 프로그램을 사용하는 이를 말한다.  
이는 한 컴퓨터에 여럿이 될 수도 있다.  
사용자는 실제 사람, 기계 또는 또다른 컴퓨터가 될 수도 있다. (서버의 경우)  

2. 시스템 혹은 응용 프로그램  
사용자가 일상적으로 사용하는 프로그램을 일컫는다.  

3. 운영 체제  
다양한 응용 프로그램과 사용자들 사이에서  
누가 어떤 자원을 쓰게 할 것인지를 제어하고 조정한다.  

4. 컴퓨터의 하드웨어  
CPU, 메모리, 입출력 장치같은 기본적인 컴퓨팅 자원을 제공한다.  

이전 글에서 설명했듯  
운영 체제 (kernel)은 사용자와 하드웨어의 중간 다리 역할을 한다.  
사용자가 응용 프로그램을 사용하면 그 프로그램은 자원을 필요로 하고  
이때 이 자원은 누가 요구한다고 막 갖다 쓸 수가 없으니  
그 사이에 운영 체제가 관여하여 자원을 분배하게 된다.  


# 컴퓨터 시스템의 조직도  

![image](https://user-images.githubusercontent.com/22045424/77043555-1ea71780-6a01-11ea-9cbb-0cf746639f26.png)

컴퓨터 시스템의 동작은 위와 같은 구조로 이루어지는데  
메모리에 있는 프로그램, 즉 '일거리'가 CPU로 보내지면 CPU가 그 일을 하게 되고,  
혹은 일의 결과가 메모리로 보내지기도 한다.  

또한 입력 장치로 입력받은 값이 메모리로 가야 할 때도 있고  
CPU에서 처리된 데이터가 메모리로,  
메모리가 다시 이를 출력하기 위해 출력 장치로 보내야 할 때도 있다.  

이때 이 일거리(명령)나 데이터가 오고 가고 하는 통로를 버스(bus)라고 한다.  
위 그림에서 장치끼리 연결된 선이 bus이다.  
다만 이 버스는 일차선 도로이기 때문에  
CPU <-> 메모리 혹은 I/O <-> 메모리의 둘 중 하나만 가능하다.  


# 컴퓨터 시스템의 동작  

입출력 장치와 CPU는 독립적으로 동시에 일을 한다.  
둘 다 장치 안에 조그마한 저장 장치를 가지고 있는데  
CPU의 경우에는 register를, 입출력 장치는 local buffer가 그것이다.  
local buffer는 입출력할 데이터를 임시 보관하며  
입력된 데이터는 이 local buffer에 잠시 저장된 후 메모리로 이동하고  
출력될 데이터는 local buffer에 잠시 저장된 후 사용자에게 보여진다.  

즉 CPU는 데이터를 register에서 메모리로 옮기고  
입출력 장치는 각 장치에서 local buffer로 옮긴다.  

입출력 장치의 컨트롤러는 각 동작이 끝나면 CPU에게 자신의 일이 끝났다고 선언하게 되는데  
이때 interrupt가 발생한다.  


# interrupt의 주요 기능  

CPU와 입출력 장치는 독립적이지만 특별한 경우 입출력 장치가 CPU에게 interrupt를 보내게 된다.  

interrupt는 일반적으로 cpu에게 interrupt vector로 interrupt 서비스 루틴을 전달한다.  
interrupt vector는 모든 서비스 루틴들이 들어있는 주소이다.  
vector는 방향이란 의미로,  
interrupt가 왜 생겼는지를 마구잡이로 찾으라는게 아니라 찾아볼 방향을 제시하는 의미이다.  

interrupt 구조는 interrupt가 발생하면 interrupted, 그러니까 중단된 명령어의 주소를 저장해야 한다.  
interrupt 처리 과정으로 넘어가기 이전에 프로그램의 정보를 저장하여 처리가 끝나고 돌아갈 곳을 알아두어야 한다.  
또한 interrupt 루틴, 즉 interrupt 처리 함수, 그리고 그 코드들은 운영 체제의 일부로,  
interrupt가 발생했다는 것은 프로그램의 제어가 운영 체제에게 넘어갔다는 말이다.  

입출력 장치가 보내는 interrupt 말고도 CPU 내부에서 발생하는 interrupt 도 존재하는데  
이를 software interrupt, 내부 interrupt라 부른다.  
trap, exception의 두 종류가 있는데, 오류(exception)라거나 사용자의 요청(trap)에 의해 발생한다.  

interrupt 처리 루틴은 interrupt 코드의 일부이며  
interrupt의 처리 결과로 운영 체제가 동작하게 된다.  
따라서 "운영 체제는 interrupt에 의해 좌우된다." (An operating system is interrupt driven.)  
라고 말할 수 있다.  


# interrupt 다루기  

운영 체제는 인터럽트가 발생하면  
그때의 레지스터와 프로그램 카운터(다음 실행될 명령어의 주소를 저장하는 특수 레지스터)를 저장해  
CPU의 상태를 저장한다.  

인터럽트가 발생하면 운영 체제는 어디서 그게 발생했는지를 알아야 하는데  
1. 장치에서 인터럽트 벡터를 보내게 되면  
어떤 장치에 맞는 인터럽트 처리 루틴을 실행할지를 알기 때문에  
그 방향(vector)에 따라 함수를 실행해 나가면 되지만  

2. 그런 거 안 보내는 장치라면 어디서 발생했는지 다 뒤져봐야 하고  
이를 polling이라고 부른다.  

코드의 서로 다른 세그먼트들이 각 인터럽트의 유형을 처리하기 위해 어떤 처리가 필요한지를 결정한다.  

![image](https://user-images.githubusercontent.com/22045424/77046765-ea365a00-6a06-11ea-96f1-d26fa5a94c25.png)  

위 그림은 CPU와 입출력 장치가 동작하는 상태를 나타낸 그림이다.  
각 장치가 두 개의 선으로 동시에 작동한다는 것은  
두 장치가 독립적으로 자기 할 일을 한다는 뜻이다.  

이렇게 독립적으로 일을 하는 도중  
1. CPU가 사용자로부터 입력을 받아라, 사용자에게 보여줘라 같은 입출력 개시 명령을 보내게 되면  
2. 놀고 있던 입출력 장치는(idle) 행동을 시작하게 된다.   
3. 장치가 일을 마치고 데이터의 전송이 끝나게 디면 인터럽트가 발생하게 되고   
4. 인터럽트가 발생한 것을 안 CPU는 그 원인을 파악하여,  
제공된 vector 내의 인터럽트 원인을 조사 후, 처리 함수를 실행한다. 이때 이 주체는 커널이다.   
5. 인터럽트의 처리가 완료되면 인터럽트가 발생되기 전으로 돌아가 하던 일을 계속한다.   
